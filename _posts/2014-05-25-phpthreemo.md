---
layout: post
title:  "PHP学习<4>"
date:   2014-05-25
desc: "我的php"
keywords: "php,面上对象"
categories: [php]
tags: [epel]
icon: icon-centos
---

面象对象的概念

    面向对象编程（Object Oriented Programming, OOP, 面向对象程序设计）是一种计算机编程架构，OOP的一条基本原则是计算机程序是由单个能够起到子程序作用的单元或对象组合而成，OOP达到了软件工程的三个目标：重用性、灵活性和扩展性。为了实现整体运算，每个对象都能够接收信息、处理数据和向其它对象发送信息。


什么是类， 什么是对象， 类和对象这间的关系

    类的概念：类是具有相同属性和服务的一组对象的集合。它为属于该类的所有对象提供了统一的抽象描述，其内部包括属性和服务两个主要部分。在面向对象的编程语言中，类是一个独立的程序单位，它应该有一个类名并包括属性说明和服务说明两个主要部分。

    对象的概念：对象是系统中用来描述客观事物的一个实体，它是构成系统的一个基本单位。一个对象由一组属性和对这组属性进行操作的一组服务组成。从更抽象的角度来说，对象是问题域或实现域中某些事物的一个抽象，它反映该事物在系统中需要保存的信息和发挥的作用；它是一组属性和有权对这些属性进行操作的一组服务的封装体。客观世界是由对象和对象之间的联系组成的。

    类与对象的关系就如模具和铸件的关系，类的实例化结果就是对象，而对一类对象的抽象就是类.类描述了一组有相同特性（属性）和相同行为（方法）的对象。


一、如何抽象出一个类

    类的定义：
```
    class类名{
    }
```
    所有类都是从属性和方法这两方面去写， 属性又叫做这个类的成员属性，方法叫做这个类的成员方法。

```
    class人{
       成员属性：姓名、性别、年龄、身高、体重、电话、家庭住址
       成员方法：可以开车， 会说英语， 可以使用电脑
    }
```


    属性：

    通过在类定义中使用关键字"var  "来声明变量，即创建了类的属性,虽然在声明成员属性的时候可以给定初值， 但是在声明类的时候给成员属性初使值是没有必要的，比如说要是把人的姓名赋上“张三”,那么用这个类实例出几十个人，这几十个人都叫张三了，所以没有必要， 我们在实例出对象后给成员属性初使值就可以了。

    如：　var  $somevar;

    方法(成员函数)：

    通过在类定义中声明函数，即创建了类的方法。

    如：　function  somefun(参数列表){
                ... ...
         }

```
<?php
     class Person
     {
         //下面是人的成员属性
         var $name;  //人的名子
         var $sex;    //人的性别
         var $age;    //人的年龄

         //下面是人的成员方法
         function say() //这个人可以说话的方法
         {
              echo "这个人在说话";
         }

         function run()  //这个人可以走路的方法
         {
              echo "这个人在走路";
         }
     }
?>
```


二、如何实例化对象

    我们上面说过面向对象程序的单位就是对象，但对象又是通过类的实例化出来的，既然我们类会声明了，下一步就是实例化对象了。当定义好类后，我们使用new关键字来生成一个对象。
     $对象名称 = new 　类名称（）；

```
<?php
     class Person
     {
         //下面是人的成员属性
         var $name;  //人的名子
         var $sex;    //人的性别
         var $age;    //人的年龄

         //下面是人的成员方法
         function say()  //这个人可以说话的方法
         {
              echo "这个人在说话";
         }

         function run()  //这个人可以走路的方法
         {
              echo "这个人在走路";
         }
     }
     $p1=new Person();
     $p2=new Person();
     $p3=new Person();
?>
$p1=new Person();
```

这条代码就是通过类产生实例对象的过程，$p1就是我们实例出来的对象名称，同理，$p2, $p3也是我们实例出来的对象名称，一个类可以实例出多个对象，每个对象都是独立的，上面的代码相当于实例出来3个人来， 每个人之间是没有联系的， 只能说明他们都是人类， 每个人都有自己的姓名， 性别和年龄的属性，每个人都有说话和走路的方法，只要是类里面体现出来的成员属性和成员方法，实例化出来的对象里面就包含了这些属性和方法。


如何去使用对象中的成员

    上面看到PHP对象中的成员有两种一种是成员属性， 一种是成员方法。对象我们以经可以声明了，$p1=new Person();  怎么去使用对象的成员呢？要想访问对象中的成员就要使用一个特殊的操作符”->”来完成对象成员的访问：
                  对象->属性    $p1->name;        $p2->age;      $p3->sex;
                  对象->方法     $p1->say();        $p2->run();
    如下面实例:

```
<?php
     class Person
     {
         //下面是人的成员属性
         var $name;  //人的名子
         var $sex;    //人的性别
         var $age;    //人的年龄

         //下面是人的成员方法
         function say()  //这个人可以说话的方法
         {
              echo "这个人在说话";
         }

         function run()  //这个人可以走路的方法
         {
              echo "这个人在走路";
         }
     }

     $p1=newPerson();  //创建实例对象$p1
     $p2=newPerson();  //创建实例对象$p2
     $p3=newPerson();  //创建实例对象$p3

     //下面三行是给$p1对象属性赋值
     $p1->name=”张三”;
     $p1->sex=”男”;
     $p1->age=20;

     //下面三行是访问$p1对象的属性
     echo “p1对象的名子是：”.$p1->name.”<br>”;
     echo “p1对象的性别是：”.$p1->sex.”<br>”;
     echo “p1对象的年龄是：”.$p1->age.”<br>”;

     //下面两行访问$p1对象中的方法
     $p1->say();
     $p1->run();

     //下面三行是给$p2对象属性赋值
     $p2->name=”李四”;
     $p2->sex=”女”;
     $p2->age=30;

     //下面三行是访问$p2对象的属性
     echo “p2对象的名子是：”.$p2->name.”<br>”;
     echo “p2对象的性别是：”.$p2->sex.”<br>”;
     echo “p2对象的年龄是：”.$p2->age.”<br>”;

     //下面两行访问$p2对象中的方法
     $p2->say();
     $p2->run();

     //下面三行是给$p3对象属性赋值
     $p3->name=”王五”;
     $p3->sex=”男”;
     $p3->age=40;

     //下面三行是访问$p3对象的属性
     echo “p3对象的名子是：”.$p3->name.”<br>”;
     echo “p3对象的性别是：”.$p3->sex.”<br>”;
     echo “p3对象的年龄是：”.$p3->age.”<br>”;

     //下面两行访问$p3对象中的方法
     $p3->say();
     $p3->run();

?>
```

    从上例中可以看出只是对象里面的成员就要使用对象->属性 、对象->方法      形式访问，再没有第二种方法来访问对象中的成员了。


三、特殊的引用“$this“的使用

    现在我们知道了如何访问对象中的成员，是通过”对象->成员”的方式访问的,这是在对象的外部去访问对象中成员的形式， 那么如果我想在对象的内部，让对象里的方法访问本对象的属性，或是对象中的方法去调用本对象的其它方法这时我们怎么办？因为对象里面的所有的成员都要用对象来调用，包括对象的内部成员之间的调用，所以在PHP里面给我提供了一个本对象的引用$this， 每个对象里面都有一个对象的引用$this来代表这个对象，完成对象内部成员的调用, this的本意就是“这个”的意思， 上面的实例里面，我们实例化三个实例对象$P1、 $P2、 $P3，这三个对象里面各自存在一个$this分别代表对象$p1、$p2、$p3 。

    $this->属性   $this->name;              $this->age;    $this->sex;
    $this->方法     $this->say();              $this->run();


四、构造方法与析构方法

    大多数类都有一种称为构造函数的特殊方法。当创建一个对象时，它将自动调用构造函数，也就是使用new这个关键字来实例化对象的时候自动调用构造方法。

    构造函数的声明与其它操作的声明一样，只是其名称必须是__construct( )。这是PHP5中的变化，以前的版本中，构造函数的名称必须与类名相同，这种在PHP5中仍然可以用，但现在以经很少有人用了，这样做的好处是可以使构造函数独立于类名，当类名发生改变时不需要改相应的构造函数名称了。为了向下兼容，如果一个类中没有名为__construct( )的方法，PHP将搜索一个php4中的写法,与类名相同名的构造方法。

　  格式：function __construct ( [参数] ) { ... ... }

    在一个类中只能声明一个构造方法，而是只有在每次创建对象的时候都会去调用一次构造方法，不能主动的调用这个方法，所以通常用它执行一些有用的初始化任务。比如对成属性在创建对象的时候赋初值。

```
<?
    //创建一个人类
    class Person
    {
        //下面是人的成员属性
        var $name;  //人的名子
        var $sex;    //人的性别
        var $age;    //人的年龄

        //定义一个构造方法参数为姓名$name、性别$sex和年龄$age
        function__construct($name, $sex, $age)
        {
            //通过构造方法传进来的$name给成员属性$this->name赋初使值
            $this->name=$name;
            //通过构造方法传进来的$sex给成员属性$this->sex赋初使值
            $this->sex=$sex;
            //通过构造方法传进来的$age给成员属性$this->age赋初使值
            $this->age=$age;
        }

        //这个人的说话方法
        function say()
        {
            echo "我的名子叫：".$this->name."性别：".$this->sex."我的年龄是：".$this->age."<br>";
        }
    }

    //通过构造方法创建3个对象$p1、p2、$p3,分别传入三个不同的实参为姓名、性别和年龄
    $p1=new Person(“张三”，”男”, 20);
    $p2=new Person(“李四”，”女”, 30);
    $p3=new Person(“王五”，”男”, 40);

    //下面访问$p1对象中的说话方法
    $p1->say();
    //下面访问$p2对象中的说话方法
    $p2->say();
    //下面访问$p3对象中的说话方法
    $p3->say();
?>
```

输出结果为：

我的名子叫：张三 性别：男 我的年龄是：20
我的名子叫：李四 性别：女 我的年龄是：30
我的名子叫：王五 性别：男 我的年龄是：40



析构函数：

    与构造函数相对的就是析构函数。析构函数是PHP5新添加的内容，在PHP4中没有析构函数。析构函数允许在销毁一个类之前执行的一些操作或完成一些功能，比如说关闭文件， 释放结果集等，析构函数会在到某个对象的所有引用都被删除或者当对象被显式销毁时执行，也就是对象在内存中被销毁前调用析构函数。与构造函数的名称类似，一个类的析构函数名称必须是__destruct( )。析构函数不能带有任何参数。
　  格式：function __destruct ( ){ ... ... }

```
<?
//创建一个人类
class Person
       {
              //下面是人的成员属性
              var$name;  //人的名子
              var$sex;    //人的性别
              var$age;    //人的年龄

              //定义一个构造方法参数为姓名$name、性别$sex和年龄$age
              function__construct($name, $sex, $age)
              {
                     //通过构造方法传进来的$name给成员属性$this->name赋初使值
                     $this->name=$name;
                     //通过构造方法传进来的$sex给成员属性$this->sex赋初使值
                     $this->sex=$sex;
                     //通过构造方法传进来的$age给成员属性$this->age赋初使值
                     $this->age=$age;
              }

            //这个人的说话方法
            function say()
            {
                  echo"我的名子叫：".$this->name." 性别：".$this->sex."我的年龄是：".$this->age."<br>";
            }

                  //这是一个析构函数，在对象销毁前调用
                  function __destruct()
                  {
                         echo “再见”.$this->name.”<br>”;
                  }
        }

        //通过构造方法创建3个对象$p1、p2、$p3,分别传入三个不同的实参为姓名、性别和年龄
        $p1=new Person(“张三”，”男”, 20);
        $p2=new Person(“李四”，”女”, 30);
        $p3=new Person(“王五”，”男”, 40);

        //下面访问$p1对象中的说话方法
        $p1->say();
        //下面访问$p2对象中的说话方法
        $p2->say();
        //下面访问$p3对象中的说话方法
        $p3->say();
?>
```
输出结果为：

我的名子叫：张三 性别：男 我的年龄是：20
我的名子叫：李四 性别：女 我的年龄是：30
我的名子叫：王五 性别：男 我的年龄是：40

再见张三
再见李四
再见王五

五、封装性

    封装性是面象对象编程中的三大特性之一，封装性就是把对象的属性和服务结合成一个独立的相同单位，并尽可能隐蔽对象的内部细节，包含两个含义:1.把对象的全部属性和全部服务结合在一起，形成一个不可分割的独立单位（即对象）。2.信息隐蔽，即尽可能隐蔽对象的内部细节，对外形成一个边界〔或者说形成一道屏障〕，只保留有限的对外接口使之与外部发生联系。

    封装的原则在软件上的反映是：要求使对象以外的部分不能随意存取对象的内部数据（属性），从而有效的避免了外部错误对它的"交叉感染"，使软件错误能够局部化，大大减少查错和排错的难度。

    用个实例来说明吧，假如某个人的对象中有年龄和工资等属性，像这样个人隐私的属性是不想让其它人随意就能获得到的，如果你不使用封装，那么别人想知道就能得到，但是如果你封装上之后别人就没有办法获得封装的属性， 除非你自己把它说出去，否则别人没有办法得到。

    在比如说，个人电脑都有一个密码，不想让其它人随意的登陆，在你电脑里面拷贝和粘贴。还有就是像人这个对象， 身高和年龄的属性， 只能是自己来增涨，不可以让别人随意的赋值等等。

    使用private这个关键字来对属性和方法进行封装：

    原来的成员:

    var $name;                   //声明人的姓名
    var $sex;                      //声明人的性别
    var $age;                      //声明人的年龄
    function run(){ …….}

    改成封装的形式：

    private $name;                            //把人的姓名使用private关键字进行封装
    private $sex;                                    //把人的性别使用private关键字进行封装
    private $age;                                    //把人的年龄使用private关键字进行封装
    private function  run(){……}          //把人的走路方法使用private关键字进行封装

    注意：只要是成员属性前面有其它的关键字就要去掉原有的关键字”var”.

    通过private就可以把人的成员（成员属性和成员方法）封装上了。封装上的成员就不能被类外面直接访问了，只有对象内部自己可以访问；下面的代码会产生错误：

```
class Person
        {
              //下面是人的成员属性
              private $name;   //人的名子，被private封装上了
              private $sex;    //人的性别, 被private封装上了
              private $age;    //人的年龄, 被private封装上了

              //这个人可以说话的方法
              function say()
              {
                     echo "我的名子叫：".$this->name."性别：".$this->sex."我的年龄是：".$this->age."<br>";
              }

              //这个人可以走路的方法, 被private封装上了
              private function run()
              {
                     echo"这个人在走路";
              }
       }
       //实例化一个人的实例对象
       $p1=new Person();

       //试图去给私有的属性赋值， 结果会发生错误

       $p1->name="张三";
       $p1->sex="男";
       $p1->age=20;

       //试图去打印私有的属性， 结果会发生错误

       echo$p1->name.”<br>”;
       echo$p1->sex.”<br>”;
       echo$p1->age.”<br>”

       //试图去打印私有的成员方法， 结果会发生错误
       $p1->run();
?>
```
输出结果为：

Fatal error:Cannot access private property Person::$name
Fatal error:Cannot access private property Person::$sex
Fatal error:Cannot access private property Person::$age
Fatal error:Cannot access private property Person::$name
Fatal error:Call to private method Person::run() from context

从上面的实例可以看到， 私有的成员是不能被外部访问的， 因为私有成员只能在本对象内部自己访问，比如，$p1这个对象自己想把他的私有属性说出去，在say()这个方法里面访问了私有属性，这样是可以。（没有加任何访问控制，默认的是public的，任何地方都可以访问）

```
//这个人可以说话的方法, 说出自己的私有属性，在这里也可以访问私有方法

function say()
    {
        echo"我的名子叫：".$this->name." 性别：".$this->sex."我的年龄是：".$this->age."<br>";
        //在这里也可以访问私有方法
        //$this->run();
    }


因为成员方法say()是公有的， 所以我们在类的外部调用say()方法是可以的，改变上面的代码；

class Person

{

              //下面是人的成员属性

              private $name; //人的名子，被private封装上了

              private $sex;    //人的性别, 被private封装上了

              private $age;    //人的年龄, 被private封装上了

              //定义一个构造方法参数为私有的属性姓名$name、性别$sex和年龄$age进行赋值
              function__construct($name, $sex, $age)
              {
                     //通过构造方法传进来的$name给私有成员属性$this->name赋初使值
                     $this->name=$name;
                     //通过构造方法传进来的$sex给私有成员属性$this->sex赋初使值
                     $this->sex=$sex;
                     //通过构造方法传进来的$age给私有成员属性$this->age赋初使值
                     $this->age=$age;
              }

              //这个人可以说话的方法, 说出自己的私有属性，在这里也可以访问私有方法
              function say()
              {
                     echo"我的名子叫：".$this->name." 性别：".$this->sex."我的年龄是：".$this->age."<br>";
              }
       }

        //通过构造方法创建3个对象$p1、p2、$p3,分别传入三个不同的实参为姓名、性别和年龄

        $p1=new Person(“张三”，”男”, 20);
        $p2=new Person(“李四”，”女”, 30);
        $p3=new Person(“王五”，”男”, 40);

        //下面访问$p1对象中的说话方法
       $p1->say();
       //下面访问$p2对象中的说话方法
       $p2->say();
       //下面访问$p3对象中的说话方法
       $p3->say();
?>
```
输出结果为：

   我的名子叫：张三 性别：男 我的年龄是：20
   我的名子叫：李四 性别：女 我的年龄是：30
   我的名子叫：王五 性别：男 我的年龄是：40

因为构造方法是默认的公有方法（构造方法不要设置成私有的），所以在类的外面可以访问到，这样就可以使用构造方法创建对象， 另外构造方法也是类里面的函数，所以可以用构造方法给私有的属性赋初值。Say()的方法是默认公有的， 所以在外面也可以访问的到， 说出他自己的私有属性。

从上面的例子中我们可以看到， 私有的成员只能在类的内部使用， 不能被类外部直接来存取， 但是在类的内部是有权限访问的， 所以有时候我们需要在类的外面给私有属性赋值和读取出来，也就是给类的外部提供一些可以存取的接口，上例中构造方法就是一种赋值的形式， 但是构造方法只是在创建对象的时候赋值，如果我们已经有一个存在的对象了，想对这个存在的对象赋值， 这个时候，如果你还使用构造方法传值的形式传值， 那么就创建了一个新的对象，并不是这个已存在的对象了。所以我们要对私有的属性做一些可以被外部存取的接口，目的就是可以在对象存在的情况下，改变和存取属性的值，但要注意，只有需要让外部改变的属性才这样做，不想让外面访问的属性是不做这样的接口的，这样就能达到封装的目的，所有的功能都是对象自己来完成，给外面提供尽量少的操作。

    如果给类外部提供接口，可以为私有属性在类外部提供设置方法和获取方法，来操作私有属性.例如：
```
   prvate $age;   //私有的属性年龄

   functionsetAge($age)  //为外部提供一个公有设置年龄的方法
   {
          if($age<0|| $age>130) //在给属性赋值的时候，为了避免非法值设置给属性
          return;
          $this->age=$age;
   }

    functiongetAge()             //为外部提供一个公有获取年龄的方法
    {
           return($this->age);
    }
```
上面的方法是为一个成员属性设置和获取值， 当然你也可以为每个属性用同样的方法对其进行赋值和取值的操作，完成在类外部的存取工作。

六、__set() __get() __isset() __unset()四个方法的应用

一般来说，总是把类的属性定义为private，这更符合现实的逻辑。但是，对属性的读取和赋值操作是非常频繁的，因此在PHP5中，预定义了两个函数”__get()”和”__set()”来获取和赋值其属性,以及检查属性的”__isset()”和删除属性的方法”__unset()”。

之前，我们为每个属性做了设置和获取的方法，在PHP5中给我们提供了专门为属性设置值和获取值的方法，”__set()”和“__get()”这两个方法，这两个方法不是默认存在的，而是我们手工添加到类里面去的，像构造方法(__construct())一样, 类里面添加了才会存在，可以按下面的方式来添加这两个方法，当然也可以按个人的风格来添加：

```
//__get()方法用来获取私有属性

    function __get($property_name)
    {
        if(isset($this->$property_name)) {
              return($this->$property_name);
        }else {
              return(NULL);
        }
    }

    //__set()方法用来设置私有属性
    function __set($property_name,$value)
    {
        $this->$property_name= $value;
    }

```


__get()方法：这个方法用来获取私有成员属性值的,有一个参数， 参数传入你要获取的成员属性的名称，返回获取的属性值，这个方法不用我们手工的去调用， 是在直接获取私有属性的时候自动调用的。因为私有属性已经被封装上了，是不能直接获取值的（比如：”echo $p1->name” 这样直接获取是错误的），但是如果你在类里面加上了这个方法，在使用”echo $p1->name” 这样的语句直接获取值的时候就会自动调用__get($property_name)方法，将属性name传给参数$property_name，通过这个方法的内部执行，返回我们传入的私有属性的值。

__set()方法：这个方法用来为私有成员属性设置值的，有两个参数，第一个参数为你要为设置值的属性名，第二个参数是要给属性设置的值，没有返回值。这个方法同样不用我们手工去调用，是在直接设置私有属性值的时候自动调用的，同样属性私有的已经被封装上了，如果没有__set()这个方法，是不允许的， 比如：”$this->name=’zhangsan’ , 这样会出错，但是如果你在类里面加上了__set($property_name, $value)这个方法，在直接给私有属性赋值的时候，就会自动调用它，把属性比如name传给$property_name,把要赋的值”zhangsan”传给$value，通过这个方法的执行，达到赋值的目的， 为了不传入非法的值，还可以在这个方法给做一下判断。代码如下：

```
<?php
       classPerson
       {
              //下面是人的成员属性， 都是封装的私有成员
              private $name;  //人的名子
              private $sex;    //人的性别
              private $age;   //人的年龄

              //__get()方法用来获取私有属性

              function __get($property_name)
              {
                  echo "在直接获取私有属性值的时候，自动调用了这个__get()方法<br>";
             if(isset($this->$property_name)) {
                            return($this->$property_name);
                      }else {
                            return(NULL);
                     }
              }

              //__set()方法用来设置私有属性

              function __set($property_name, $value)
              {
                     echo "在直接设置私有属性值的时候，自动调用了这个__set()方法为私有属性赋值<br>";
                     $this->$property_name= $value;
              }
       }

       $p1=newPerson();

       //直接为私有属性赋值的操作， 会自动调用__set()方法进行赋值

       $p1->name="张三";
       $p1->sex="男";
       $p1->age=20;

       //直接获取私有属性的值， 会自动调用__get()方法，返回成员属性的值
       echo "姓名：".$p1->name."<br>";
       echo "性别：".$p1->sex."<br>";
       echo "年龄：".$p1->age."<br>";
?>
```
程序执行结果：

在直接设置私有属性值的时候， 自动调用了这个__set()方法为私有属性赋值
在直接设置私有属性值的时候， 自动调用了这个__set()方法为私有属性赋值
在直接设置私有属性值的时候， 自动调用了这个__set()方法为私有属性赋值
在直接获取私有属性值的时候，自动调用了这个__get()方法
姓名：张三
在直接获取私有属性值的时候，自动调用了这个__get()方法
性别：男
在直接获取私有属性值的时候，自动调用了这个__get()方法
年龄：20

以上代码如果不加上__get()和__set()方法，程序就会出错，因为不能在类的外部操作私有成员，而上面的代码是通过自动调用__get()和__set()方法来帮助我们直接存取封装的私有成员的。

七、类的继承
    继承作为面向对象的三个重要特性的一个方面，在面向对象的领域有着及其重要的作用，好像没听说哪个面向对象的语言不支持继承。继承是php5面象对象程序设计的重要特性之一，它是指建立一个新的派生类，从一个或多个先前定义的类中继承数据和函数，而且可以重新定义或加进新数据和函数，从而建立了类的层次或等级。说的简单点就是，继承性是子类自动共享父类数据结构和方法的机制，这是类之间的一种关系。在定义和实现一个类的时候，可以在一个已经存在的类的基础之上来进行，把这个已经存在的类所定义的内容作为自己的内容，并加入若干新的内容。比如你现在已经有一个“人”这个类了，这个类里面有两个成员属性“姓名和年龄”以及还有两个成员方法“说话的方法和走路的方法“，如果现在程序需要一个学生的类， 因为学生的也是人， 所以学生也有成员属性“姓名和年龄”以及成员方法“说话的方法和走路的方法“，这个时候你就可以让学生类来继承人这个类，继承之后，学生类就会把人类里面的所有的属性都继承过来， 就不用你再去重新声明一遍这些成员属性和方法了， 因为学生类里面还有所在学校的属性和学习的方法，所以在你做的学生类里面有继承自人类里面的属性和方法之外在加上学生特有的”所在学校属性“和”学习的方法“, 这样一个学生类就声明完成了， 继函我们也可以叫作“扩展”, 从上面我们就可以看出，学生类对人类进行了扩展，在人类里原有两个属性和两个方法的基础上加上一个属性和一个方法扩展出来一个新的学生类。

    通过继承机制，可以利用已有的数据类型来定义新的数据类型。所定义的新的数据类型不仅拥有新定义的成员，而且还同时拥有旧的成员。我们称已存在的用来派生新类的类为基类，又称为父类以及超类。由已存在的类派生出的新类称为派生类，又称为子类。

    在软件开发中，类的继承性使所建立的软件具有开放性、可扩充性，这是信息组织与分类的行之有效的方法，它简化了对象、类的创建工作量，增加了代码的可重性。采用继承性，提供了类的规范的等级结构。通过类的继承关系，使公共的特性能够共享，提高了软件的重用性。

    在C++语言中，一个派生类可以从一个基类派生，也可以从多个基类派生。从一个基类派生的继承称为单继承；从多个基类派生的继承称为多继承。


    但是在PHP和Java语言里面没有多继承，只有单继承，也就是说，一个类只能直接从一个类中继承数据，这就是我们所说的单继承。

  例如：

  下面是“人”类的抽象

```
//定义一个“人”类做为父类

class Person

    {
      //下面是人的成员属性
      var $name; //人的名子
      var $sex;   //人的性别
      var $age;    //人的年龄

    //定义一个构造方法参数为属性姓名$name、性别$sex和年龄$age进行赋值
    function__construct($name, $sex, $age)
    {
         $this->name=$name;
         $this->sex=$sex;
         $this->age=$age;
    }

          //这个人可以说话的方法, 说出自己的属性
          function say()
          {
                 echo"我的名子叫：".$this->name." 性别：".$this->sex."我的年龄是：".$this->age."<br>";
          }
    }
```

  通过上面“Student“类的定义， Student类通过使用”extends”这个关键字把Person 类里的所有成员属性和成员方法都继承过来了, 并扩展了一个所在学校成员属性”school”，和一个学习方法“study()”.  现在子类”Student”里面和使用这个类实例出来的对象都具有如下的属性和方法:
  学生类”Student”里面的成员属性有：
  姓名：name;
  年龄：age;
  性别：sex;
  学校：school;
  学生类”Student”里面的成员方法有：
  说话方法：say();
  学习方法：study();

  通过上面类继承的使用简化了对象、类的创建工作量，增加了代码的可重性。但是从上面这一个例子上中“可重用性”以及其它的继承性所带来的影响，我们看的还不是特别的明显，你扩展的去想一下，人有无数个岗位，比如上面的学生还有老师，工程师，医生，工人等，很多很多，如果每个类都定义“人“都共同具有的属性和方法， 想一想会有很大的工作量， 这些属性和方法都可以从“Person”人类里面继承过来。

